\thispagestyle{empty}
\changepage{}{}{}{-1.5cm}{}{2cm}{}{}{}
![The Little MongoDB Book, By Karl Seguin](title.png)\

\clearpage
\changepage{}{}{}{1.5cm}{}{-2cm}{}{}{}

## この本について ##

### ライセンス ###
「The Little MongoDB Book」はAttribution-NonCommercial 3.0 Unportedライセンスです。**この本に対価を支払うべきではありません。**

この本は自由にコピー、再配布、修正、表示を行うことができます。しかしながら、常に著者名（Karl Seguin）を表示し、営利目的に利用しないことを求めます。

ライセンスの全文。
<http://creativecommons.org/licenses/by-nc/3.0/legalcode>

### 著者について ###

Karl Seguinは様々な技術分野における経験豊かな開発者です。.NETとRubyの専門家です。オープンソースソフトウェアに対してやや積極的な貢献者で、テクニカルライターで、不定期に講演も行います。MongoDBに関しては、NoRM（C#のMongoDbライブラリ）のコアコントリビュータで、対話的チュートリアル[mongly](http://mongly.com/)と[Mongo Web Admin](https://github.com/karlseguin/Mongo-Web-Admin)を開発しました。彼が開発したカジュアルゲームの開発者向けの無料サービス[mogade.com](http://mogade.com/)はMongoDBを利用しています。
Karlはかつて[The Little Redis Book](http://openmymind.net/2012/1/23/The-Little-Redis-Book/)を書きました。

ブログ: <http://openmymind.net>
Twitter: [@karlseguin](http://twitter.com/karlseguin)

### 謝辞 ###

[Perry Neal](https://twitter.com/#!/perryneal)の洞察と判断力と情熱に特別な感謝を。計り知れないほどの助けをもらった。ありがとう。

### 最新版 ###

この本の最新版のソースは以下にあります。
<https://github.com/karlseguin/the-little-mongodb-book>

### 日本語翻訳について ###

松永肇一が日本語への翻訳を行いました。日本語訳の誤りは知らせていただけると助かります。
Twitter: [@ma2](http://twitter.com/ma2)

\clearpage

## イントロダクション ##
>この本が短いのは著者の落ち度ではない。MongoDBがそれほど学びやすいということだ。

技術がものすごい勢いで変化するとはよく言われる。新規技術が次々と現れ公開されるのならばこれは真実だ。しかしながら私が長年思ってきたのは、プログラマが使う基本技術はむしろゆっくりとしたペースで変化するということだ。何年もかけてさほど今日的ではないことを学ぶこともあった。技術が置き換わるスピードはまさに電撃的だ。一夜にして長い間確立されてきた技術から開発の中心が移ってしまったことに脅かされることになる。

RDBに対するNoSQLの成長ほど、これを表しているものはない。ウェブがほんの2～3のRDBMで開発されていたかと思った次の日には、5種類ほどのNoSQLが検討するに足るソリューションとして確立されていた。

この変化は一夜にして起きたように見えるが、実際にはそれらが受け入れられるまでには何年もかかった。最初に熱狂したのは数少ない開発者と企業だった。ソリューションは磨きをかけられ、教訓が学ばれ、新しい技術が根付くのを見て、他の人々が試し始めた。またNoSQLにおいては、多くのソリューションが伝統的なデータベース技術を置き換えるものではなく、むしろ追加の特定のニーズを満たすためのものであるということも一面の真実だ。

まず最初にNoSQLの意味を説明すべきだろう。NoSQLは広い意味を持つ用語で、人が変われば意味も変わる。個人的には、データストレージを扱うシステムを広く意味するために使う。言い換えれば、NoSQL（繰り返すが個人的には）とは永続層が単一システムの責務である必要がないという信念のことだ。RDBのベンダーは歴史的に「1つで全てのニーズを満たす」ソリューションとして彼らのソフトウェアを位置づけてきたが、NoSQLは、与えられた仕事に最適なツールを活用するという小さな責務よりだ。だからNoSQLシステムが依然としてRDB（例えばMySQL）を利用してもいいが、永続層のルックアップにRedisを使ったり、大規模データ処理にHadoopを使ってもいい。簡単にいえば、NoSQLはデータの処理に関するパターンやツールに対する別の選択肢に対して、オープンかつ意識的であることだ。

ではMongoDBはどれに当たるのだろうかと疑問に思っていることだろう。ドキュメント指向データベースとしてMongoは汎用的なNoSQLソリューションで、リレーショナルデータベースの代替としてみるべきだ。リレーショナルデータベースと同じく、より特化したNoSQLと組み合わせても恩恵を受けられる。MongoDBには利点も欠点もあり、それはこの本の中で述べる。

すでにお気づきのことだと思うが、MongoとMongoDBはこの本では同じ意味で使う。

## はじめる ##

この本の大部分はMongoDBのコア機能に触れており、MongoDBシェルを利用している。このシェルは学習ツールとしても管理者ツールとしても優秀だが、プログラムはMongoDBのドライバを使うことになる。
したがってMongoDBについて知っておくべき最初のことはドライバだ。MongoDBには多くの言語用に[公式ドライバ](http://www.mongodb.org/display/DOCS/Drivers)がある。これは、いままで慣れ親しんだデータベースのドライバと同じものだと思っていい。これらのドライバを使って、開発者コミュニティがプログラミング言語やフレームワーク固有のライブラリを構築してきた。例えば[NoRM](https://github.com/atheken/NoRM)はLINQを実装したC#のドライバ、[MongoMapper](https://github.com/jnunemaker/mongomapper)はActiveRecordと親和性の高いrubyのライブラリだ。直接MongoDBのドライバを使うのも、高水準のライブラリを使うのも自由だ。ここで言及したのは、多くの新米MongoDB開発者が公式ドライバとコミュニティによるライブラリで迷うからだ。前者は一般的にMongoDBの基本的な接続に重点を置き、後者は言語とフレームワークにより依存した実装だ。

この本を読み進めながら出てくる例を実際に試して、自身の疑問点を確認することをお勧めする。MongoDBのインストールと起動は簡単なので、ここで数分とって設定することにしよう。

1) [公式のダウンロードページ](http://www.mongodb.org/downloads)から使っているOSを合ったバイナリを、ページの一番上の行のリンク（安定バージョン）からダウンロードする。目的に応じて32ビット/64ビットバージョンを選べる。

2) アーカイブを展開して、`bin`フォルダを開く。まだ何も実行してはいけない。`mongod`がサーバで`mongo`がクライアントシェルということは知っておくこと。この2つにはこれからずっとお世話になる。

3) `bin`フォルダの中に`mongodb.config`というファイルを作る

4) mongodb.configに次の一行を追加する`dbpath=データベースを格納するディレクトリ`。例えばWindowsなら`dbpath=c:\mongodb\data`、Linuxなら`dbpath=/etc/mongodb/data`というようにする。

5) 指定したパスが実際にあることを確認する

6) mongodに`--config /path/to/your/mongodb.config`パラメータを付けて起動する

Windowsの例を挙げると、`c:\mongodb\`にダウンロードして、`c:\mongodb\data\`を作り、`c:\mongodb\bin\mongodb.config`ファイルを編集して、`dbpath=c:\mongodb\data\`を追加する。そしてコマンドラインから`c:\mongodb\bin\mongod --config c:\mongodb\bin\mongodb.config`と入力して`mongod`を起動する。

`bin`フォルダをPATHに追加してもよい。MacOSXとLinuxユーザもほぼ同じようにすればよい。唯一変えなければならないのはパスだけだ。
願わくばMongoDBが起動して動作していればいいのだが。エラーになったら出力を注意深くよむこと。MongoDBサーバーは何がうまくいかないか非常にうまく説明する。
これで`mongo`（最後の*d*無し）を起動して、シェルをサーバに接続できる。`db.version()`と入力して全てがあるべきかたちで動作していることを確認しよう。インストールしたバージョン番号を見ることができるはずだ。

\clearpage

## 1. MongoDBの基本 ##

まずMogoDBの基本的な仕組みを知ることから始めよう。MongoDBを知るというだけでなく、MongoDBが何に向いているかという高度な疑問に答える助けにもなる。
はじめに、６つのシンプルなコンセプトを理解する必要がある。

1. MongoDBは既存の`データベース`と同じコンセプトを持つ。MongoDBのインスタンスには０個以上のデータベースがあり、それぞれあらゆるものを格納するコンテナとして機能する。

2. データベースは０個以上の`コレクション`を持つ。コレクションは`テーブル`とほぼ同じ概念を持つので、両者を同じものとみなしても問題ない。

3. コレクションは０個以上の`ドキュメント`からなる。ドキュメントもまた`列`と同じものとみなしてよい。

4. ドキュメントは１つ以上の`フィールド`からなり、これは想像通り`カラム`と考えていい。

5. `インデクス`はRDBのインデクスとほとんど同じものである。

6. `カーソル`は、他の５つのコンセプトは異なり、非常に重要だが見落とされていることが多く、個人的には単体で議論する価値があると思う。カーソルについて理解すべき重要な点は、データを取得する際、MongoDBは実際にはデータではなくカーソルを返し、これを使ってカウントしたりスキップしたり何でもできる点である。

まとめると、MongoDBは`データベース`から構成され、`データベース`は複数の`コレクション`を含む。１つの`コレクション`は複数の`ドキュメント`を含む。各`ドキュメント`は`フィールド`からなる。`コレクション`には`インデクス`を張ることができ、検索や並び替えの性能を上げる。最後にMongoDBからデータを取るときは`カーソル`経由で行い、実際のデータは必要になるまで取得されない。

なぜ新しい用語が必要なのかと疑問に思うかもしれない（コレクションとテーブル、ドキュメントと列、フィールドとカラム）。単に物事を複雑にしているだけではないかと。実はこれらのコンセプトはとてもよく似ているが同じではないからなのだ。根本的な違いは、伝統的なデータベースが`カラム`を`テーブル`に定義するのに対して、ドキュメント指向データベースは`フィールド`を`ドキュメント`単位で定義することから生じる。これはひとつの`コレクション`内の各`ドキュメント`が独自の`フィールド`を持つことを意味する。この意味で、`コレクション`は`テーブル`に比べると単なる入れ物に近く、`ドキュメント`は`列`以上の情報を持つことになる。

今述べたことは重要だが、完全に理解できなくても問題ない。これが何を意味しているか少し触ってみればすぐ明らかになる。結局のところ、ドキュメントが思ったほど厳密なものではない（スキームレスである）ということがポイントだ。フィールドは個々のドキュメントが管理している。このメリットとデメリットについては後の章で述べる。

実際に試してみよう。まだやってないのなら、まず`mongod`サーバと`mongo`シェルを起動しよう。このシェルはJavaScriptを動かしている。`help`や`exit`といったグローバルコマンドがある。カレントのデータベースに対するコマンドは、`db.help()`や`db.stats()`のように`db`オブジェクトに対して実行する。特定のコレクションに対するコマンドは、`db.unicorns.help()`や`db.unicorns.count()`のように`db.COLLECTION_NAME`オブジェクトに対して実行する。

まず`db.help()`と入力しよう。`db`オブジェクトに対して実行できるコマンド一覧が表示される。

余談だが、JavaScriptのシェルなので`()`を忘れるとメソッドが実行されずにメソッドの定義が表示される。ここでこれを述べるのは`function(...){`から始まるレスポンスを見ても驚かないでほしいからだ。例えば`db.help`（後ろにカッコなし）と入力すると、`help`メソッドの実装を見ることになる。

最初にグローバルな`use`コマンドを使ってデータベースを切り替えよう。`use learn`と入力してみよう。データベースが存在しなくてもかまわない。最初にコレクションを作成するときに`learn`データベースも作られる。さて、いまはデータベース内にいるので、`db.getCollectionNames()`などのデータベースコマンドを使うことができる。実際にやってみると空配列（`[]`）が返ってくる。コレクションはスキーマレスなので、明示的にスキーマを作る必要はない。単にドキュメントを新しいコレクションにインサートすることができる。そのためにinsertコマンドを使い、インサートするドキュメントを渡す。

	db.unicorns.insert({name: 'Aurora', gender: 'f', weight: 450})

上のコマンドは`unicorns`コレクションに対して１パラメータの`insert`コマンドを実行する。内部的にはMongoDBはバイナリJSON形式を使う。外部的には、ここでやったようにJSONを多用することになる。いま`db.getCollectionNames()`を実行すると、`unicorns`と`system.indexes`の２つのコレクションがあることが分かる。`system.indexes`はデータベースに対して１つ作られて、インデクス情報を保持する。

`unicorns`に対して`find`コマンドを使うとドキュメント一覧を取得できる。

	db.unicorns.find()

指定したデータに加えて`_id`というフィールドがあることに注意されたい。すべてのドキュメントはユニークな`_id`フィールドを持たねばならない。自分で作ることも、MongoDBにObjectIdを作らせることもできる。ほとんどの場合MongoDBに作らせることになるだろう。デフォルトでは`_id`フィールドはインデクスされている。これが`system.indexes`ができた理由だ。`system.indexes`の中身は次のようにして見ることができる。

	db.system.indexes.find()

表示されるのはインデクスの名前、データベースとコレクションの名前、その他インデクスに含まれるフィールド名だ。

さてスキーマレスコレクションの話に戻ろう。`unicorns`に全く異なる構造のドキュメントをインサートしてみる。

	db.unicorns.insert({name: 'Leto', gender: 'm', home: 'Arrakeen', worm: false})

`find`コマンドでドキュメント一覧を表示してみよう。もう少し理解した時点で、このMongoDBの興味深いふるまいについて議論するが、少なくともなぜ伝統的なRDB用語がここではうまくフィットしないのかを理解できればと思う。

### セレクタを理解する ###

MongoDBには、これまで見てきた６つの原則に加えて、理解しておくと今後役に立つ現実的な側面がある。クエリーセレクタだ。MongoDBのクエリーセレクタはSQLの`where`節に似ている。ドキュメントの検索、集計、更新、削除などに使うことができる。セレクタはJSONオブジェクトで、最も単純なもの`{}`は全てのドキュメントにマッチする（`null`も同様だ）。メスのユニコーンを検索したいのなら`{gender:'f'}`を使えばいい。

セレクタに深く入る前に、利用するデータを入力しておく。まず`db.unicorns.remove()`で`unicorns`コレクション内にインサートしたものを全て削除する（セレクタを渡さないと全てが対象になる）。次に以下のコマンドでデータをインサートする（コピペ推奨）。

	db.unicorns.insert({name: 'Horny', dob: new Date(1992,2,13,7,47), loves: ['carrot','papaya'], weight: 600, gender: 'm', vampires: 63});
	db.unicorns.insert({name: 'Aurora', dob: new Date(1991, 0, 24, 13, 0), loves:['carrot', 'grape'], weight: 450, gender: 'f', vampires: 43});
	db.unicorns.insert({name: 'Unicrom', dob: new Date(1973, 1, 9, 22, 10), loves:['energon', 'redbull'], weight: 984, gender: 'm', vampires: 182});
	db.unicorns.insert({name: 'Roooooodles', dob: new Date(1979, 7, 18, 18, 44),loves: ['apple'], weight: 575, gender: 'm', vampires: 99});
	db.unicorns.insert({name: 'Solnara', dob: new Date(1985, 6, 4, 2, 1), loves:['apple', 'carrot', 'chocolate'], weight:550, gender:'f', vampires:80});
	db.unicorns.insert({name:'Ayna', dob: new Date(1998, 2, 7, 8, 30), loves: ['strawberry', 'lemon'], weight: 733, gender: 'f', vampires: 40});
	db.unicorns.insert({name:'Kenny', dob: new Date(1997, 6, 1, 10, 42), loves: ['grape', 'lemon'], weight: 690, gender: 'm', vampires: 39});
	db.unicorns.insert({name: 'Raleigh', dob: new Date(2005, 4, 3, 0, 57), loves:['apple', 'sugar'], weight: 421, gender: 'm', vampires: 2});
	db.unicorns.insert({name: 'Leia', dob: new Date(2001, 9, 8, 14, 53), loves: ['apple', 'watermelon'], weight: 601, gender: 'f', vampires: 33});
	db.unicorns.insert({name: 'Pilot', dob: new Date(1997, 2, 1, 5, 3), loves: ['apple', 'watermelon'], weight: 650, gender: 'm', vampires: 54});
	db.unicorns.insert({name: 'Nimue', dob: new Date(1999, 11, 20, 16, 15), loves:['grape', 'carrot'], weight: 540, gender: 'f'});
	db.unicorns.insert({name: 'Dunx', dob: new Date(1976, 6, 18, 18, 18), loves: ['grape', 'watermelon'], weight: 704, gender: 'm', vampires: 165});

これでセレクタを試すことができる。`{フィールド:値}`は、フィールドが'値'であるようなドキュメントを検索するのに使う。`{フィールド1:値1, フィールド2:値2}`はANDを意味する。特殊な記号`$lt`、`$lte`、`$gt`、`$gte`、`$ne`は、小さい、以下、大きい、以上、等しくないを求める演算子である。例えば700ポンド以上のオスのユニコーンを検索するには以下のようにできる。

	db.unicorns.find({gender: 'm', weight: {$gt: 700}})

以下のようにもできる。厳密には同じではないが、演算子のデモのために示す。

	db.unicorns.find({gender: {$ne: 'f'}, weight: {$gte: 701}})

`$exist`演算子はドキュメントにそのフィールドがあるか調べるために使う。

	db.unicorns.find({vampires: {$exists: false}})

とやると、`vampires`フィールドを持たないドキュメント（ここでは１つ）を返す。
ANDではなくOR演算を行いたい場合は、`$or`演算子にセレクタの配列を渡す。

	db.unicorns.find({gender: 'f', $or: [{loves: 'apple'}, {loves: 'orange'}, {weight: {$lt: 500}}]})

これは'apple'か'orange'が好きか500ポンド以下のメスのユニコーンを返す。
最後の例にはすてきなものがある。すでに気づいていると思うがloveフィールドは配列だ。MongoDBは配列を基本型としてサポートしている。これは信じられないぐらい便利な機能だ。一度使ってしまうと、これなしに今までどうやってたんだろうと思うようになる。そしてもっと興味深いのは配列の値を検索するのがいかに簡単かということだ。`{loves: 'watermelon'}`は、`loves`の値に`watermelon`が含まれる全てのドキュメントを返す。

ここに示した以外にもたくさんの演算子がある。最も柔軟な`$where`はJavaScriptを受け取ってサーバ上で実行することができる。これらは全てMongoDBサイトの[Advanced Queries](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries)に記述がある。ここに示したのは学ぶのに必要な基本的なものだけだ。しかし多くの場合これで事足りる。

セレクタにおける`find`コマンドの使い方を見てきた。セレクタは`remove`コマンドでも（すでに簡単に触れた）、`count`コマンドでも（見当が付いていると思う）、`update`コマンドでも（後で詳しく述べる）使うことができる。
なおMongoDBが`_id`フィールド用に生成するObjectIdもセレクタの対象にできる。

	db.unicorns.find({_id: ObjectId("TheObjectId")})

### まとめ ###

まだ`update`コマンドも、`find`のもっと面白い機能も学んでいない。しかしMongoDBを起動し、`insert`と`remove`コマンドを簡単に学んだ。`find`コマンドを使ってMongoDBのセレクタが何かを見た。よいスタートをきり、基本を確実に学んだ。信じられないかもしれないが、MongoDBについて知るべきことはほとんど学んでしまったのだ。MongoDBは本当に覚えやすく使いやすい。先に進む前にMongoDBで遊んで見ることを強くお勧めする。異なるドキュメントをインサートし、新しいコレクションを作り、様々なセレクタを試す。`find`、`count`、`remove`を使ってみる。何度か自分で試してみれば、最初は扱いにくいと思ったものが、収まるべきところに収まるだろう。

\clearpage

## 2. 更新 ##

一章でCRUD（`create`、`read`、`update`、`delete`）操作のうちの３つを学んだ。この章は残りの一つ`update`について述べる。`update`はいくつかの驚くべき挙動を示す。わざわざ一章を割く理由だ。

### 更新: 置換と$set ###

一番単純な構文では`update`は２つのパラメータをとる。セレクタと更新するフィールドだ。Roooooodlesがやや太りすぎなので、以下のコマンドを実行する。

	db.unicorns.update({name: 'Roooooodles'}, {weight: 590})

（もし`unicorns`コレクションをすっかり書き換えてしまっているのなら、一度削除して１章のコートを使ってインサートしなおして欲しい）
実際のコードならおそらく`_id`で更新するが、MongoDBがどのような`_id`を割り当てるかは分からないので`name`を使う。では更新したドキュメントを見てみよう。

	db.unicorns.find({name: 'Roooooodles'})

`update`の最初の驚きを見たはずだ。指定した二番目のパラメータ`{weight: 590}`が元のドキュメントを**置換**するために使われたため、ドキュメントは見つからない。言い換えると、`update`は`name`で検索して、そのドキュメントを新しいドキュメント`{weight: 590}`で置き換えたのだ。これはSQLの`update`の動作とは異なる。これが有効な場合もあり、真に動的な更新に活用できる。しかしフィールドを１つだけ（あるいは少しだけ）変えたい場合には、`$set`修飾子を使うのがベストだ。

	db.unicorns.update({weight: 590}, {$set: {name: 'Roooooodles', dob: new Date(1979, 7, 18, 18, 44), loves: ['apple'], gender: 'm', vampires: 99}})

これでなくなったフィールドが復活する。新しい`weight`フィールドも置き換えない（`weight`を指定していないので）。改めて以下のコマンドを実行する。

	db.unicorns.find({name: 'Roooooodles'})

期待した結果になる。`weight`フィールドだけを更新する正しいやり方は以下のとおりだ。

	db.unicorns.update({name: 'Roooooodles'}, {$set: {weight: 590}})

### 更新修飾子 ###

`$set`以外にも修飾子がある。全ての修飾子はフィールドに対して機能するので、ドキュメントがなくなることはない。例えば`$inc`修飾子はフィールドを指定した数増減するために使われる。例えばPilotがvampireを殺した数が間違っていたと分かれば、以下のようにして修正できる。

	db.unicorns.update({name: 'Pilot'}, {$inc: {vampires: -2}})

Auroraが突然甘党になっても、`$push`修飾子で`loves`フィールドに値を追加できる。

	db.unicorns.update({name: 'Aurora'}, {$push: {loves: 'sugar'}})

MongoDBサイトの[Updating](http://www.mongodb.org/display/DOCS/Updating)には、他の更新修飾子に関する多くの情報がある。

### 更新型インサート（Upsert） ###

`update`のうれしい驚きのひとつは、それが`upsert`をサポートしていることだ。`upsert`はドキュメントが見つかれば更新して、見つからなければインサートする。`upsert`は特定の状況では非常に便利で、そういう状況になれば自然と分かる。`upsert`を使えるようにするには、三番目のパラメータとして`true`を渡せばよい。

平凡な例としてはウェブサイトのヒットカウンタがある。リアルタイムにカウントしようとするなら、そのページにレコードがあるかどうか確認して、それに応じて更新かインサートかを決める必要がある。三番目のパラメータがないと、以下のコマンドは何も実行しない。

	db.hits.update({page: 'unicorns'}, {$inc: {hits: 1}});
	db.hits.find();

しかし`upsert`を使うようにすると、結果はまるで違う。

	db.hits.update({page: 'unicorns'}, {$inc: {hits: 1}}, true);
	db.hits.find();

`unicorns`には`page`フィールドを持つドキュメントは存在しないので、新しいドキュメントがインサートされる。もう一度同じコマンドを実行すると、すでにあるドキュメントが更新されて`hits`が2になる。

	db.hits.update({page: 'unicorns'}, {$inc: {hits: 1}}, true);
	db.hits.find();

### 多重更新（Multiple Update） ###

`update`による最後の驚きは、それが（デフォルトでは）ひとつのドキュメントだけを更新するということだ。今まで見た限りでは、これは論理的に思えるかもしれない。しかしこのようにしてみる。

	db.unicorns.update({}, {$set: {vaccinated: true }});
	db.unicorns.find({vaccinated: true});

全ての高貴なユニコーンにワクチンが打たれることを期待すると思う（が、そうならない）。期待の結果にするためには、四番目のパラメータを`true`にセットする必要がある。

	db.unicorns.update({}, {$set: {vaccinated: true }}, false, true);
	db.unicorns.find({vaccinated: true});

まとめ

この章で、コレクションに対して実行できる基本的なCRUD操作の紹介を完了した。`update`を詳しくみて、３つの興味深いふるまいを観察した。SQLの`update`とは異なり、MongoDBの`update`は実際のドキュメントを置き換えること。したがって`$set`修飾子が便利なこと。次に、`update`は直感的な`upsert`をサポートしており、`$inc`修飾子と一緒に使うと特に便利なこと。最後に、`update`は最初に見つかったドキュメントだけを更新するのがデフォルトであること。

今まで見てきたMongoDBのふるまいはシェルを通したものであることを覚えておいて欲しい。使っているドライバやライブラリによってはデフォルトが異なっていたり、APIが異なっていたりする。例えばRubyのドライバは、最後の２つのパラメータを、`{:upsert => false, :multi => false}`といった１つのハッシュで表現している。

\clearpage

## 3. 検索を使いこなす ##

一章ではごく表面的に`find`コマンドに触れた。`find`については`セレクタ`を理解するよりもたくさんのことがある。`find`の結果は`カーソル`であると述べた。これが正確には何を意味するのかより詳しく見ていこう。

### フィールド選択 ###

`カーソル`に進む前に、`find`が二番目のオプションパラメータについて知る必要がある。このパラメータは、処理したいフィールドのリストだ。例えば全てのユニコーンの名前は次のようにして得られる（フィールドの値に1を渡すと、そのフィールドが返ってくる）。

	db.unicorns.find(null, {name: 1});

デフォルトでは`_id`フィールドは常に返される。`{name:1, _id: 0}`とすることで、`_id`フィールドを明示的に除くことができる。

### 並び替え ###

何度か述べたように`find`は`カーソル`を返し、実際の実行は必要になるまで遅延される。しかしシェルを見るかぎり、明らかに`find`は即時に実行されている。これはシェルだけのふるまいだ。`カーソル`の真の動作は`find`にメソッドをつなげることで観察できる。最初に`sort`を見てみよう。`sort`は前章で述べたフィールド選択のように機能する。ソートしたいフィールドを指定して、昇順には1，降順には-1を指定する。例を示す。

	// 一番太ったユニコーン
	db.unicorns.find().sort({weight: -1})
	// 名前でソートして、同じなら殺したバンパイアの数
	db.unicorns.find().sort({name: 1, vampires: -1})

RDBと同様に、MongoDBはソートにインデクスを使える。インデクスについては後述する。しかしインデクスのないソートのサイズ制限については知っておくべきだ。インデクスのない巨大なリザルトセットをソートしようとするとエラーになる。これを制限だと見る人もいる。実際の話、もっと多くのデータベースが最適化されていないクエリーを拒否するようになればいいと思う（MongoDBの全ての欠点を擁護しようとは思わないが、strictモードがあればいいのにと思うほどひどいデータベースをたくさん見てきたのだ）。

### ページング ###

ページングは`limit`と`skip`というカーソルメソッドで実現する。二番目と三番目に重いユニコーンを得るには、以下のようにする。

	db.unicorns.find().sort({weight: -1}).limit(2).skip(1)

`sort`と一緒に`limit`を使うのは、インデクスのないフィールドをソートするときの問題を避けるよい手段だ。

### カウント ###

シェルではコレクションに直接`count`を実行できる。

	db.unicorns.count({vampires: {$gt: 50}})

実際には`count`はカーソルメソッドで、シェルはショートカットを提供しているだけだ。ドライバがそうしたショートカットを提供していないのなら、以下のようにする必要がある（これはシェルでも動作する）。

	db.unicorns.find({vampires: {$gt: 50}}).count()

### まとめ ###

`find`と`カーソル`は素直な組み合わせだ。後の章で出てくるか特殊な状況で使うようなコマンドはいくつかあるが、これでmongoシェルを使ったり、MongoDBの基礎を理解するには十分に学んだ。

\clearpage

## 4. データモデリング ##

少しギアを切り替えて、MongoDBの抽象的な話をしよう。新しい用語や新しい文法を説明するのは簡単だ。新しいパラダイムのモデリングについて語るのは簡単ではない。真実を言えば、これら新しい技術がモデリングの世界にきたとき、何ができて何ができないのかは未だ発見の途中なのだ。現時点での話はできるが、結局は実際のコードで学んでいくしかない。

ほとんどのNoSQLと違って、データモデリングにおいてドキュメント指向データベースとRDBとの相違点は非常に少ない。相違点はわずかだが、それが重要でないという意味ではない。

### 結合（join） ###

最初のそして最大の相違点はMongoDBに結合が無いということだ。いくつかのタイプの結合がMongoDBでサポートされていない明確な理由はわからないが、一般的に結合がスケーラブルでないことはよく知っている。このため、データを一度水平分割してしまえば、結合の性能はあきらめないとならない。理由はともあれ、データがリレーショナル*である*という事実は残り、MongoDBは結合をサポートしない。

他のことを学ぶ前に、結合のない世界で生きるために、結合はアプリケーション内で自分自身で行わなければならない。関連データを`find`するためにもう一度クエリーを発行する必要がある。データを設定するのはRDBで外部キーを宣言するのと変わらない。`unicorns`コレクションから離れて`emplyees`コレクションを作ってみよう。まず`employee`コレクションを作る。

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d730"), name: 'Leto'})

次にLetoをマネージャとする従業員を追加する。

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d731"), name: 'Duncan', manager: ObjectId("4d85c7039ab0fd70a117d730")});
	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d732"), name: 'Moneo',manager: ObjectId("4d85c7039ab0fd70a117d730")});

（`_id`はユニークならどんな値でもいいことは繰り返しておく価値があるだろう。実際にObjectIdを使うこともあるだろうから、ここでも使ってみた）

もちろんLetoの従業員を検索するには以下のようにすればよい。

	db.employees.find({manager: ObjectId("4d85c7039ab0fd70a117d730")})

何も不思議なことはない。最悪の場合（たいていそうだが）、結合が無いというのは単によけいなクエリー（たぶんインデクスされたフィールドに対して）が必要だということだけだ。

### 配列と埋め込みドキュメント（Embedded Documents） ###

MongoDBに結合がなくても、奥の手がある。配列をファーストクラスオブジェクトとしてサポートしていると簡単に触れたことを覚えているだろうか。これが一対多や多対多の関連を扱うのにとても便利なのだ。簡単な例として、従業員が二人のマネージャを持つとすると、マネージャを配列にできる。

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d733"), name: 'Siona',manager: [ObjectId("4d85c7039ab0fd70a117d730"), ObjectId("4d85c7039ab0fd70a117d732")] })

特に興味深いのは、あるドキュメントでは`manager`フィールドはスカラーであり、別のドキュメントでは配列であるということだ。元の`find`クエリーはどちらに対しても機能する。

	db.employees.find({manager: ObjectId("4d85c7039ab0fd70a117d730")})

多対多のジョインテーブルよりも配列の方が便利であるとすぐに分かるはずだ。

配列とは別に、MongoDBは埋め込みドキュメントをサポートしている。ネストしたドキュメントをインサートしてみよう。

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d734"), name: 'Ghanima', family: {mother: 'Chani', father: 'Paul', brother: ObjectId("4d85c7039ab0fd70a117d730")}})

疑問に思っているかもしれないが、埋め込みドキュメントはドット記法でクエリーに記述できる。

	db.employees.find({'family.mother': 'Chani'})

埋め込みドキュメントがどのような場合に適していて、どう使うべきかは後に簡単に述べることにする。

### DBRef ###

MongoDBには多くのドライバが慣習的に`DBRef`としてサポートしている機能がある。ドライバが`DBRef`を見つけると、自動的に参照先のドキュメントを取得する。`DBRef`には、参照するドキュメントのidとコレクションが含まれている。極めて限定された目的、すなわち、同じコレクションのドキュメント（群）が異なるコレクションのドキュメント（群）を相互に参照するのに使われる。つまり、ドキュメント1の`DBRef`が`managers`の中のドキュメントを参照していて、そのドキュメント2の`DBRef`が`employees`の中のドキュメントを参照している。

### 非正規化 ###

結合を使わない別の手としては非正規化がある。歴史的には非正規化は性能を追い求めるコードや、データをスナップショットしたい（会計記録のような）場合に使われてきた。しかしNoSQLが広まるにつれ（その多くは結合をサポートしていない）、通常のモデリングのひとつとして非正規化を使うことはどんどん一般的になってきている。これは、あらゆるドキュメントでどんな情報も重複して持てということではない。しかし、データの重複を恐れるような設計をするよりは、どのドキュメントにどの情報が属しているかに基づくデータモデリングを考慮しよう。

例えば、フォーラムアプリを作っているとしよう。伝統的な方法では、ある`post`と特定の`user`を`posts`テーブルの`user_id`カラムで関連付ける。このモデルでは`users`を結合しない限り`posts`を表示することはできない。別の方法では、各`post`に`user_id`だけでなく`name`を持つ。これは

	user: {id: ObjectId('Something'), name: 'Leto'}

のようにして、埋め込みドキュメントで実現できる。そう、もしユーザが名前を変更したら、ドキュメントを更新する必要がある（ひとつよけいなクエリー）。

この種のアプローチに慣れるのは簡単ではない人もいる。多くの場合これはやる意味すら持たない。しかし、体験することを恐れてはいけない。いくつかの状況に適しているだけでなく、これこそが正しい場合もある。

### どちらを選べばいいか？ ###

１対多、多対多を扱う場合idの配列は常に有用だ。`DBRef`はそれほど使われていないと言ってもいいだろう。ただし必ず使うときがくる。埋め込みドキュメントと手動参照のどちらを使うかはいつも新規の開発者を迷わせる。

まず、個々のドキュメントに4MBの制限があることを知る必要がある。これは非常に大きなサイズだが、どう使うべきかのヒントになる。現時点では、多くの開発者がほとんどの関連に手動参照を使っているようだ。埋め込みドキュメントはよく利用されるが、親ドキュメント内に常に置いておきたい小規模なデータの場合が多い。実例を挙げるとユーザに`account`ドキュメントを格納するのに以下のように使った。

	db.users.insert({name: 'leto', email: 'leto@dune.gov', account: {allowed_gholas: 5, spice_ration: 10}})

埋め込みドキュメントを過小評価したり、マイナーな機能として抹殺したりすべきではない。データモデルをオブジェクト中にマップできる機能は、物事を大幅に単純化するし、しばしば結合の必要性をなくしてくれる。これは埋め込みドキュメントのフィールドをクエリーしたりインデクスしたりする場合は特に言えることだ。

### コレクションの数 ###

コレクションは全くスキーマに関わらないので、あらゆるドキュメントを１つのコレクションに全部入れてしまうことも可能だ。今まで見てきたように、MongoDBのシステムの大部分はRDBにあるものを基本にしている。言い方を変えると、RDBでテーブルにするようなものなら、MongoDBでもコレクションにするのが適している（多対多のジョインテーブルは重要な例外だ）。

埋め込みドキュメントのことを考慮すると、この話はより興味深い。よく出てくる例はブログだ。`posts`コレクションと`comments`コレクションを作るべきか、それとも各`post`の中に`comment`の配列を埋め込むべきか。4MBの制限は忘れるとして（ハムレット全文は200KBに見たない。あなたのブログの人気はどれほどだろうか）、ほとんどの開発者はそれぞれ別に置くことを好む。その方が単純に分かりやすいし、より明確だ。

決まったルールはない（そう。4MBは別だ）。いろいろなアプローチを試せば、何がうまくいき、なにがいかないかの感覚を身につけることができるだろう。

### まとめ ###

この章の目的はMongoDBにおけるデータモデリングの有益なガイドラインを提供することだった。その気があればここが出発点だ。ドキュメント指向システムにおけるモデリングは変わっているが、関連という視点からはそれほど大きな相違はない。少しだけ柔軟になり、ひとつの制限があるが、どちらかといえば各機能は非常にうまく調和している。一番悪いのは試してみないことだ。

\clearpage

## 5. MongoDBを使うのはどのような場合か ##

ここまで読んで、MongoDBをどこでどのように既存のシステムに適用していくかが十分理解できたはずだ。膨大な選択肢に圧倒されそうな、競合する新しいデータベース技術がたくさんある。

個人的に最も重要なことは、MongoDBとは関係なく、データ処理に際して単一解に頼らなくてもよくなったことだ。疑いもなく、単一解は多くのプロジェクト、たぶんほとんどのプロジェクトで明らかな利点を持ち、理にかなったアプローチだ。ここで言っているのは、異なった技術を使わねばならないということではなく、使うことができるということだ。新しい解決策を導入する利益がコストを上回るかどうかは分かっている。

そうは言うものの、今まで見てきたことでMongoDBを汎用的なソリューションとみなしてもらえると期待している。何度も繰り返したように、ドキュメント指向データベースはRDBと多くを共有している。だからためらわずにMongoDBはRDBの直接の代替手段だと明言してしまおう。Luceneを全文検索によるRDBの拡張とみなすなら、Redisを永続的KVSとみなすなら、MongoDBはデータのメインのリポジトリだ。

MongoDBをRDBの*代替*であって*置き換え*とは言わなかったことに注意して欲しい。MongoDBはツールであって、他のツールでも同じことはできる。いくつかはMongoDBの方がうまくやれて、いくつかはうまくやれない。もう少し詳しく見ていこう。

### スキーマレス ###

ドキュメント指向データベースの喧伝されている利点といえば、スキーマレスだ。これにより、ドキュメント指向データベースは、伝統的なデータベースのテーブルより柔軟性に富んでいる。スキーマレスがよい機能であることには賛同するが、それは多くの人が言うような理由からではない。

まるででたらめなデータをすぐにデータベースに入れるかのように人々はスキーマレスを語る。確かにRDBを使ってモデル化することが苦痛になるような領域やデータは存在するが、それは特殊な例だと思う。スキーマレスはクールだ。しかしほとんどのデータは高度に構造化されている。不整合なデータを格納してもいいというのは便利なこともある、特に新機能を追加しているときなどだ。しかし実際にはNULL値を持てるカラムがあれば同じように問題を解決できる。

個人的には、スキーマレス設計の本当の利点は、セットアップが不要で、オブジェクト指向との親和性が高いことだ。特に静的言語を使うときに言える。MongoDBをC#とRubyで使ったが、違いは著しい。Rubyの動的な性格とAcriveRecordの実装はオブジェクトとRDBのインピーダンスミスマッチをすでにかなり解消している。MongoDBがRubyにマッチしていないと言っているのではない。事実すばらしくマッチしている。むしろ多くのRuby開発者はMongoDBを着実な進歩とみなし、これに対してJavaやC#の開発者はデータをやりとりする方法の根本的な変化とみなすだろう。

ドライバの開発者の視点からみてみる。オブジェクトを保存したい？　JSONに（技術的にはBSONに。ほとんど同じだ）シリアライズしてMongoDBに送りたまえ。属性や型のマッピングは不要だ。この単純さはそのまま開発者に届く。

### 書き込み ###

MongoDBが特に向いている領域としてはロギングがある。MongoDBの書き込みが高速なのには2つの側面がある。ひとつは書きこみコマンドを発行するとMongoDBは書きこみ終了を待たずにすぐに戻ること。もう一つはバージョン1.8で導入され2.0で強化されたジャーナリングのおかげで、耐障害性に応じて書き込みのふるまいを制御できることだ。何台のサーバがデータを取得できたら成功とみなすのかの指定に加えて、この2つは書き込み毎に設定可能で、書き込み性能と耐障害性の大幅な制御を可能にしている。

こうした性能要素に加えて、ログデータはしばしばスキーマレスの恩恵を受けるデータのひとつだ。最後に付け加えるとMongoDBには[capped collection](http://www.mongodb.org/display/DOCS/Capped+Collections)と呼ばれる機能がある。今まで暗黙的に作っていたコレクションは通常のコレクションだ。`db.createCollection`コマンドを使い`capped`を指定すると、`capped collection`を作れる。

	// 1MB上限のcapped collection
	db.createCollection('logs', {capped: true, size: 1048576})

この`capped collection`が1MBに達すると、古いドキュメントから自動的に削除される。コレクションのサイズではなくドキュメントの数で制限するは`max`を指定する。`capped collection`は、いくつかの興味深い性質を持つ。例えばドキュメントの更新はできてもサイズを増やすことはできない。またインサート順序は保持されるので、時間順に並び替えるためによけいなインデクスを追加する必要もない。

書き込みがなんらかのエラーに遭遇したかどうかを知りたい（デフォルトでは書きこんでそれきりだが）のなら、`db.getLastError()`を発行すればよい。ほとんどのドライバはこれを*safe write*としてカプセル化しており、例えば`insert`の第二パラメータとして`{:safe => true}`を指定する。

### 耐障害性 ###

バージョン1.8より前のMongoDBには、シングルサーバ耐障害性がなかった。もしそのサーバがクラッシュすればデータの消失につながっていた。解決策として、MongoDBを常にマルチサーバ構成で動作させていた（レプリケーションに対応している）。1.8で追加された重要な機能はジャーナリングだ。これを有効にするには、MongoDBを最初にセットアップしたときに作った`mongodb.config`に`journal=true`を追加する（すぐに有効にしたければリスタートする）。たぶんジャーナリングは有効にしたいと思うだろう（将来のバージョンではデフォルトで有効になる予定）。しかし、ジャーナリングをオフにすることで得られる性能向上のために、あえて自らリスクをとる状況があるかもしれない（データを失っても問題ないアプリがあることを指摘しておく価値はあるだろう）。

データ消失の大部分はシングルサーバ耐障害性がないときの話なので、耐障害性についてはここで述べるにだけにする。ググると色々出てくるかもしれない。耐障害性がないというのは単純に昔の話だ。

### 全文検索 ###

完全な全文検索機能は将来のMongoDBに期待される機能だ。配列サポートがあるので、基本的な全文検索は簡単に実装できる。もっと強力な機能が必要なら、LuceneやSolrなどのソリューションが必要だ。もちろんこれは多くのRDBでも同様だ。

### トランザクション ###

MongoDBにトランザクションは無い。代替は2つあって、ひとつは素晴らしいが限定的で、もうひとつは使いにくいが柔軟性に富む。

最初のはアトミック操作だ。問題に合致さえしていれば完璧だ。すでに`$inc`や`$set`といった簡単な例を見てきた。更新や削除したドキュメントを返す`findAndModify`などのコマンドもある。

二番目のは、アトミック操作だけでは不十分なとき、ツーフェーズコミットへのフォールバックだ。トランザクションに対するツーフェーズコミットは、結合に対する手動参照のようなものだ。データベースとは無関係にコードの中で行う。RDBの世界では、複数のデーベース間のトランザクションを実現する手段として、ツーフェーズコミットは普通に使われている。MongoDBサイトには一般的なケース（お金の移動）を[図解したサンプル](http://cookbook.mongodb.org/patterns/perform-two-phase-commits/)がある。実際に更新されるドキュメント内にトランザクションの状態を格納して、初期化-待機-コミット-ロールバックを自分でやるというのが、基本的なアイデアだ。

MongoDBにはネストしたドキュメントとスキーマレス設計をサポートしているので、ツーフェーズコミットはやや簡単になるが、それでも素晴らしい処理とはいえない。とくに始めたばかりなら。

### データ処理 ###

MongoDBのほとんどのデータ処理はマップリデュース（MapReduce）に依存している。基本的な[集約機能](http://www.mongodb.org/display/DOCS/Aggregation)はあるが、大したものではなく、マップリデュースを使いたくなるだろう。次章でマップリデュースの詳細を見る。ここではマップリデュースは非常に強力で`group by`とはまったく異なる方法だと思っておけばよい。マップリデュースの強みの一つは、巨大なデータに対して並列化できることだ。しかしMongoDB実装はJavaScriptベースで、これはシングルスレッドだ。問題点？　巨大データを処理するにはHadoopのような別のシステムを頼る必要がある。感謝すべきことに、この2つのシステムはお互いを補完するので、[Hadoop用MongoDBアダプタ](https://github.com/mongodb/mongo-hadoop)もある。

もちろんデータ処理の並列化はRDBが得意とするところではない。MongoDBの将来のバージョンでは巨大データの処理を改良する予定だ。

### 空間情報（Geospatial） ###

空間情報サポートは、MongoDBの特に強力な機能だ。x座標とy座標の値をドキュメントに格納して、`$near`（1点からの距離）や`$winthin`（矩形または円形の内部かどうか）で検索できる。この機能は視覚のほうが分かりやすいので、詳しく知りたいのであれば[5分で分かる空間情報入門](http://tutorial.mongly.com/geo/index)を試すことをお勧めする。

### ツールと成熟度 ###

すでに答えはお分かりのことと思う。MongoDBは大部分のRBDに比べて明らかに若い。これは必ず考慮すべき点だ。何をどうやるかによって扱うものの価値は決まる。しかし正直な評価をすればMongoDBが新しいプロジェクトで、ツール群がまだ整備されていない（といっても成熟したRDBのツールもひどいものが多い！）ことは無視できない。一例を挙げると、十進浮動小数のサポートがないのはお金を扱うシステムにとって明らかな懸案事項（必ずしも致命的ではないが）になる。

いい点を挙げると、多くの重要な言語用のドライバが存在し、プロトコルはモダンでシンプルで、ものすごい勢いで開発されている。多くの企業で実際に使われ、成熟度に関する懸念は急速に過去のものになりつつある。

### まとめ ###

MongoDBは、多くの場合、RDBを置き換えることが可能だというのがこの章のメッセージだ。より単純、より分かりやく、より高速、一般的に開発者に強いる制限もより少ない。トランザクションがないのは合理的だが重大な懸案事項だ。しかし人々が*MongoDBは新しいデータベースシーンでどのへんに位置するのか？*と問うのなら答えは簡単だ。**ど真ん中に**。

\clearpage

## 6. マップリデュース（MapReduce） ##

マップリデュースは伝統的なソリューションに対して2つの大きな利点のあるデータ処理アプローチだ。これが開発された第一のそして最大の理由は、性能だ。理論的には、マップリデュースは、複数のマシン、CPU、コアに渡る大規模なデータを並列化できる。前述したように、これは現時点ではMongoDBでは活かすことはできない。二番目の利点は、データ処理に本物のコードを書けるということだ。SQLでできることと比べると、マップリデュースのコードははるかにリッチで、特定用途のソリューションを使わなくても済むほどだ。
マップリデュースは人気になりつつあるパターンで、C#、Ruby、Java、Pythonなどほとんどどの言語でも使うことができる。マップリデュースはとても変わっていて複雑だということを最初に警告しておきたい。途中で挫折せず、時間をとって自分で試してほしい。MongoDBを使うかどうかに関わらず理解する価値があるのだ。

### 理論と実際 ###

マップリデュースは二段階のプロセスだ。まずマップして、次にリデュースする。マップは入力のドキュメントを変形してキーバリューのペア（キー=>値）を出力（emit）する（キー、バリューは複合値でもいい）。リデュースではキーとその値の配列から最終出力を生成する。各ステップとその出力を見ていく。

ここで使う例は、リソース（例えばウェブページ）の一日当たりのヒット数をレポートするものだ。これはマップリデュースの`hello world`だ。ここでの目的のために、`resource`と`date`のフィールドを持つ`hits`コレクションを使う。期待する出力は、`resource`、`year`、`month`、`day`ごとに分かれた`count`だ。
`hits`コレクションに以下のデータがあるとする。

	resource   date
	index      Jan 20 2010 4:30
	index      Jan 20 2010 5:30
	about      Jan 20 2010 6:00
	index      Jan 20 2010 7:00
	about      Jan 21 2010 8:00
	about      Jan 21 2010 8:30
	index      Jan 21 2010 8:30
	about      Jan 21 2010 9:00
	index      Jan 21 2010 9:30
	index      Jan 22 2010 5:00

期待する出力は以下のとおり。

	resource   year   month   day   count
	index      2010   1       20    3
	about      2010   1       20    1
	about      2010   1       21    3
	index      2010   1       21    2
	index      2010   1       22    1

このタイプの解析手段のいいところは、出力を格納するとき、レポートを高速に作成できて、なおかつデータ量をコントロールできる（リソース毎に一日あたり１ドキュメントを追加するだけ）ことだ。

さしあたってコンセプトの理解に集中しよう。この章の終わりで、自分で試せるようコードとデータを掲載する。

まずマップ関数を見よう。マップのゴールはリデュースできる値を出力（emit）することだ。マップでは0回以上のemitが可能だ。今回は一度だけemitする（これは普通のこと）。マップをhits内の全ドキュメントに対するループだと思ってほしい。書くドキュメントに対して、resource、year、month、dayの複合キーと単純値1をemitしたい。

	function() {
	    var key = {
	        resource: this.resource,
	        year: this.date.getFullYear(),
	        month: this.date.getMonth(),
	        day: this.date.getDate()
	    };
	    emit(key, {count: 1});
	}

thisは現在のドキュメントを示す。願わくば、マップの出力を見ることで理解しやすくなると思う。上述のデータを使うと、出力は以下のようになる。

	{resource: 'index', year: 2010, month: 0, day: 20} => [{count: 1}, {count: 1},{count:1}]
	{resource: 'about', year: 2010, month: 0, day: 20} => [{count: 1}]
	{resource: 'about', year: 2010, month: 0, day: 21} => [{count: 1}, {count: 1},{count:1}]
	{resource: 'index', year: 2010, month: 0, day: 21} => [{count: 1}, {count: 1}]
	{resource: 'index', year: 2010, month: 0, day: 22} => [{count: 1}]

この中間段階の理解がマップリデュース理解への鍵だ。emitによる値は、キーごとに配列としてグループ化されている。.NETやJavaを使う開発者なら`IDictionary<object, IList<object>>`（.NET）や`HashMap<Object, ArrayList>`（Java）だと考えることができる。

マップ関数を怪しい方法で変形してみよう。

	function() {
	    var key = {resource: this.resource, year: this.date.getFullYear(),
	        month: this.date.getMonth(), day: this.date.getDate()};
	    if (this.resource == 'index' && this.date.getHours() == 4) {
	        emit(key, {count: 5});
	    } else {
	        emit(key, {count: 1});
	    }
	}

中間の出力の最初の行は以下のようになる。

	{resource: 'index', year: 2010, month: 0, day: 20} => [{count: 5}, {count: 1},{count:1}]

emitがキーでグループ化された新しい値をどのように生成するかに注意しよう。

リデュース関数はこの中間結果を受け取って最終結果を生成する。以下のコードになる。

	function(key, values) {
	    var sum = 0;
	    values.forEach(function(value) {
	        sum += value['count'];
	    });
	    return {count: sum};
	};

以下のようになる。

	{resource: 'index', year: 2010, month: 0, day: 20} => {count: 3}
	{resource: 'about', year: 2010, month: 0, day: 20} => {count: 1}
	{resource: 'about', year: 2010, month: 0, day: 21} => {count: 3}
	{resource: 'index', year: 2010, month: 0, day: 21} => {count: 2}
	{resource: 'index', year: 2010, month: 0, day: 22} => {count: 1}

技術的にはMongoDBの出力は以下のようになる。

	_id: {resource: 'home', year: 2010, month: 0, day: 20}, value: {count: 3}

これが最終結果であることに気づいてもらえただろうか。
さらに注意深ければ*なぜ単純に`sum = values.length?`としないのだろうか？*と自問するだろう。これは1の配列を合計している場合には効率的なアプローチに見える。実際には、リデュースは完全に中間データがそろった時点で呼ばれるとは限らない。例えば、以下のデータではなく、

	{resource: 'home', year: 2010, month: 0, day: 20} => [{count: 1}, {count: 1}, {count:1}]

以下のデータで呼ばれることもある。

	{resource: 'home', year: 2010, month: 0, day: 20} => [{count: 1}, {count: 1}]
	{resource: 'home', year: 2010, month: 0, day: 20} => [{count: 2}, {count: 1}]

最終的な出力はどちらも同じ（3）だが、途中経過は異なる。リデュースは常に「冪等元（べきとうげん）」でなければならない。すなわち、リデュースを何度呼び出しても一回呼び出したときと同じ結果になるべきである。

ここでは扱わないが、もっと複雑なデータ処理ではリデュースメソッドを複数つなげるのは一般的なことだ。

### 実践 ###

MongoDBでは`mapReduce`コマンドを使う。`mapReduce`はマップ関数、リデュース関数、出力ディレクティブをパラメータに取る。シェル上でJavaScript関数を作って渡すことができる。ほとんどのライブラリで、関数名を文字列で渡す（ちょっと汚い）。まずデータを作ろう。

	db.hits.insert({resource: 'index', date: new Date(2010, 0, 20, 4, 30)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 20, 5, 30)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 20, 6, 0)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 20, 7, 0)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 21, 8, 0)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 21, 8, 30)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 21, 8, 30)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 21, 9, 0)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 21, 9, 30)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 22, 5, 0)});

マップ関数とリデュース関数を作る（MongoDBのシェルは複数行の入力を受け付ける。続きが期待されるときは*...*が表示される）。

	var map = function() {
	    var key = {resource: this.resource, year: this.date.getFullYear(),
	        month: this.date.getMonth(), day: this.date.getDate()};
	    emit(key, {count: 1});
	};

	var reduce = function(key, values) {
	    var sum = 0;
	    values.forEach(function(value) {
	        sum += value['count'];
	    });
	    return {count: sum};
	};

`hits`コレクションに対して`mapReduce`コマンドを使うことができる。

	db.hits.mapReduce(map, reduce, {out: {inline:1}})

上記のコマンドを動作させると、期待する出力が得られるはずだ。`out`を`inline`に設定すると、`mapReduce`の出力がすぐに返ってくる。これは16MB以下の結果にだけ使うことができる。代わりに`{out: 'hit_stats'}`を指定して、`hit_status`コレクションに結果を格納することができる。

	db.hits.mapReduce(map, reduce, {out: 'hit_stats'});
	db.hit_stats.find();

これを実行すると`hit_stats`コレクションに元からあるデータは失われる。もし`{out: {merge: 'hit_stats'}}`とすると、既存のキーが新しい値に置換され、新しいキーが新規のドキュメントとしてインサートされる。最終的に、`reduce`関数を使って`out`すると、より高度なケースに対応できる（upsertの実行など）。

三番目のパラメータには追加のオプションがある。例えば出力に対してフィルター、ソート、リミットなどができる。また`finalize`メソッドを渡して、`reduce`ステップの結果に対して適用することもできる。

### まとめ ###

本章は、まったく新しいことについて扱う最初の章だ。不安になるかもしれないが、もっと簡単なシナリオでは[MongoDBの集約関数](http://www.mongodb.org/display/DOCS/Aggregation)がいつでも使えることを覚えておいてほしい。しかし突き詰めていけばマップリデュースこそがMongoDBの最強の機能の一つなのだ。マップ関数とリデュース関数の書き方を真に理解するには、マップ関数の出力でありリデュース関数の入力である中間データを視覚化して理解することだ。

\clearpage

## 7. 性能とツール ##

最終章ではいくつかの性能に関するトピックと、MongoDBを使う開発者に用意されているいくつかのツールについて見ていく。それぞれのトピックについて深入りはしないが、重要な側面については説明する。

### インデクス ###

最初の方でデータベースのインデクスに関する情報を格納している`system.indexes`という特別なコレクションについて述べた。MongoDBのインデクスはRDBのインデクスと同じように機能する。すなわちクエリーとソートの性能を改善する。インデクスは`ensureIndex`で作られる。

	db.unicorns.ensureIndex({name: 1});

削除するには`dropIndex`を使う。

	db.unicorns.dropIndex({name: 1});

ユニークインデクスは`unique=>true`を渡すことで生成される。

	db.unicorns.ensureIndex({name: 1}, {unique: true});

インデクスは埋め込みフィールド（ドット記法を使う）や配列フィールド上に作ることもできる。複合インデクスも作れる。

	db.unicorns.ensureIndex({name: 1, vampires: -1});

インデクスの順序（1が昇順、-1が降順）は単一キーインデクスでは意味を持たないが、複合インデクスに対してソートや範囲条件を使うときには意味を持つ。

[インデクス](http://www.mongodb.org/display/DOCS/Indexes)に追加の情報がある。

### Explain ###

クエリーがインデクスを使うかどうかを見るには、カーソル上での`explain`メソッドが使える。

	db.unicorns.find().explain()

この出力は`BasicCursor`が利用され（インデクスは使わないことを意味する）、12個のオブジェクトがスキャンされ、どのくらいかかったかを示す。使ったインデクスがあればそのインデクスの情報なども表示する。
クエリーがインデクスを使うように変更すると、`BtreeCursor`が使われたという表示になり、使われたインデクスが表示される。

	db.unicorns.find({name: 'Pilot'}).explain()

### 投げっぱなしの書き込み（Fire And Forget Writes）###

前述したように、MongoDBのデフォルトの書き込みは投げっぱなし（Fire And Forget Writes）だ。クラッシュした場合のデータ消失のリスクを負えば、これは結果的に性能向上をもたらす。この種の書き込みの興味深い副作用は、インサートや更新で単一制約違反を起こしてもエラーが返らないことだ。書き込みの失敗を知るには`db.getLastError()`をインサート後に呼び出す必要がある。ほとんどのドライバはこの細かい処理を隠蔽し、追加のパラメータで*safe write*を提供している。

不幸なことにシェルは自動的にsafe writeを実行するので、投げっぱなしのふるまいを見ることは簡単ではない。

### シャーディング ###

MongoDBは自動シャーディングをサポートしている。シャーディングはデータを複数のサーバに分割してスケールさせるアプローチだ。馬鹿正直なやり方では、ユーザデータのうちA～Mはサーバ1に、残りはサーバ2に置く。感謝すべきことにMongoDBのシャーディング機能はこの単純なアルゴリズムに比べるとずっと優れている。シャーディングはこの本で扱う範囲を超えているが、それが存在していることは知ってるべきだし、単一サーバから拡張するときには考慮すべきである。

### レプリケーション ###

MongoDBのレプリケーションはRDBのレプリケーションと似ている。書き込みはひとつのサーバ（マスタ）に送られ、マスタが複数のサーバに同期させる。スレーブ上で読み込みが発生するかどうかは設定でき、ほんの少し古いデータを読み込むリスクと引き換えに負荷を分散することができる。マスタがダウンした場合、スレーブのひとつがマスタに昇格するようにできる。レプリケーションもまたこの本で扱う範囲を超える。

レプリケーションは性能を向上させることもある（読み込みの分散で）が、本来の目的は信頼性の向上にある。レプリケーションとシャーディングを組み合わせるのはよくあるアプローチだ。例えば、各シャードをマスタとスレーブから構成してもよい（技術的には二台のスレーブがマスタになろうとしたときには調停が必要になる。しかし調停にはほんのわずかなリソースがあればよく、それも複数のシャードで使うことができる）。

### 統計（Stats） ###

`db.stats()`でデータベースの統計情報を取得できる。大部分は各種のサイズに関する情報だ。コレクションに関する統計情報は、例えば`unicorns`コレクションなら`db.unicorns.stats()`で得られる。この場合も大部分はサイズに関する情報だ。

### Webインターフェース ###

MongoDBの起動時のメッセージに、webベースの管理者ツールへのリンクが含まれている（mongodを起動したターミナルをスクロールバックすればみることができるはずだ）。ブラウザから<http://localhost:28017/>にアクセスすればアクセスできる。最大限に活用するために、`mongodb.config`に`rest=true`を追加してリスタートしたいと思うだろう。Webインターフェースはサーバの状態について多くの情報をもたらす。

### プロファイラ ###

MongoDBのプロファイラを有効にするには以下のようにする。

	db.setProfilingLevel(2);

有効になっている状態でコマンドを実行する。

	db.unicorns.find({weight: {$gt: 600}});

プロファイラをチェックする。

	db.system.profile.find()

何が実行されて、いつ、どのくらいのドキュメントがスキャンされ、どうやってデータが返されたかが分かる。

`setProfilingLevel`を引数`0`で呼べば無効にできる。`1`を指定すると100ミリ秒以上かかるクエリーだけプロファイルする。ミリ秒単位で下限を指定することもできる。

	// 1秒以上かかる処理をプロファイルする
	db.setProfilingLevel(1, 1000);

### バックアップとリストア ###

MongoDBの`bin`フォルダに`mongodump`がある。`mongodump`を実行するとローカルホストに接続して全てのデータベースを`dump`フォルダにダンプする。他のオプションを見るには`mongodump --help`とする。よく使うのは特定のデータベースをバックアップする`--db DBNAME`、特定のコレクションをバックアップする`--collection COLLECTIONAME`だ。リストアするには同じくヘクメフォルダにある`mongorestore`を使う。ダンプと同様に`--db`と`--collection`オプションが特定のデータベースとコレクションをリストアするのに使える。

例えば`learn`データベースを`backup`フォルダにバックアップするには、以下のようにする（これはmongoシェルでのコマンドではなく、ターミナルで実行するコマンドだ）。

	mongodump --db learn --out backup

`unicorns`コレクションだけリストアするには、以下のようにできる。

	mongorestore --collection unicorns backup/learn/unicorns.bson

JSONまたはCSVからデータをインポート・エクスポートできる`mongoexport`と`mongoimport`があることも指摘しておく価値があるだろう。例えば以下のようにしてJSON出力を得ることができる。

	mongoexport --db learn -collection unicorns

CSVなら以下のようにする。

	mongoexport --db learn -collection unicorns --csv -fields name,weight,vampires

`mongoexport`と`mongoimport`が常にデータを全部表現できるとは限らないことに注意しよう。`mongodump`と`mongorestore`だけが、実際のバックアップに使われるべきだ。

### まとめ ###

MongoDBの様々なコマンド、ツール、性能の詳細を見てきた。全てではないが、よく使われるものには触れた。MongoDBのインデクスは（他のツールと同様に）RDBのものと似ている。しかしMongoDBでは、それらは的を射ており使いやすいのだ。

\clearpage

## 結論 ##

MongoDBを実際のプロジェクトで使う上では十分な情報を得るべきだ。ここで扱った以上のものがMongoDBにはあるが、次はここで学んだことをまとめて、使っているドライバに習熟することを優先すべきだ。[MongoDBのサイト](http://www.mongodb.com/)には有益な情報がそろっている。[公式のユーザグループ](http://groups.google.com/group/mongodb-user)は質問をするには最適な場所だ。

NoSQLは必要にかられただけでなく、新しいアプローチへの好奇心から生まれた。この分野が日々進化しており、もし挑戦しなければ、そしてときに失敗しなければ、決して成功しないというのが共通認識だ。これは、個人的には、我々の活動を導く素晴らしい手段であると信じる。